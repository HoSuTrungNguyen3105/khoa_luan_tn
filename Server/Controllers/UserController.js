import cloudinary from "../lib/cloudinary.js";
import Notification from "../Models/notificationModel.js";
import PostModel from "../Models/postModel.js";
import UserModel from "../Models/userModel.js";
import ContractModel from "../Models/contractModel.js";
import bcrypt from "bcryptjs";
export const getUser = async (req, res) => {
  const id = req.params.id;
  try {
    const user = await UserModel.findById(id);
    if (user) {
      const { password, ...otherDetail } = user._doc;
      res.status(200).json(otherDetail);
      res.status(200).json(user); // Tr·∫£ v·ªÅ to√†n b·ªô d·ªØ li·ªáu user, bao g·ªìm c·∫£ m·∫≠t kh·∫©u
    } else {
      res.status(404).json("User not found");
    }
  } catch (error) {
    res.status(500).json(error);
  }
};

// Get a User by ID
export const getUserProfile = async (req, res) => {
  const { userId } = req.params; // L·∫•y userId t·ª´ params
  try {
    const user = await UserModel.findById(userId);

    if (user) {
      const { password, ...otherDetails } = user._doc;
      res.status(200).json(otherDetails); // Tr·∫£ v·ªÅ th√¥ng tin ng∆∞·ªùi d√πng (kh√¥ng bao g·ªìm m·∫≠t kh·∫©u)
    } else {
      res.status(404).json({ message: "User not found" });
    }
  } catch (error) {
    res.status(500).json({ message: "Error retrieving user profile" });
  }
};
export const getUserById = async (req, res) => {
  const { userId } = req.params; // L·∫•y userId t·ª´ params
  try {
    const user = await UserModel.findById(userId);

    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    // L·∫•y danh s√°ch b√†i ƒëƒÉng c·ªßa ng∆∞·ªùi d√πng
    const posts = await PostModel.find({ userId });

    // Lo·∫°i b·ªè m·∫≠t kh·∫©u tr∆∞·ªõc khi tr·∫£ v·ªÅ
    const { password, ...otherDetails } = user._doc;

    res.status(200).json({
      ...otherDetails,
      posts, // Th√™m danh s√°ch b√†i ƒëƒÉng c·ªßa user v√†o response
    });
  } catch (error) {
    console.log(error);
    res.status(500).json({ message: "Error retrieving user profile" });
  }
};
export const deleteUser = async (req, res) => {
  const id = req.params.id;
  const { currentUserId, currentUserAdminStatus } = req.body;

  if (currentUserId === id || currentUserAdminStatus) {
    try {
      const user = await UserModel.findById(id);
      if (!user) {
        return res.status(404).json("User not found");
      }

      // Th·ª±c hi·ªán x√≥a
      await UserModel.findByIdAndDelete(id);
      res.status(200).json("User deleted successfully");
    } catch (error) {
      res.status(500).json(error);
    }
  } else {
    res.status(403).json("Forbidden: Access denied");
  }
};

export const followUser = async (req, res) => {
  const userId = req.params.id; // L·∫•y userId t·ª´ URL (ng∆∞·ªùi d√πng ƒë∆∞·ª£c follow)
  const { _id } = req.body; // L·∫•y ID ng∆∞·ªùi theo d√µi t·ª´ body (ng∆∞·ªùi follow)

  if (!userId || !_id) {
    return res.status(400).json({ message: "Missing user IDs" });
  }

  try {
    // T√¨m ng∆∞·ªùi d√πng ƒë∆∞·ª£c follow
    const followUser = await UserModel.findById(userId);
    // T√¨m ng∆∞·ªùi d√πng ƒëang follow
    const followingUser = await UserModel.findById(_id);

    if (!followUser) {
      return res
        .status(404)
        .json({ message: "Ng∆∞·ªùi d√πng kh√¥ng t√¨m th·∫•y ho·∫∑c ƒë√£ x√≥a t√†i kho·∫£n" });
    }

    if (!followingUser) {
      return res.status(404).json({ message: "Ng∆∞·ªùi theo d√µi kh√¥ng t√¨m th·∫•y" });
    }

    if (!followUser.followers.includes(_id)) {
      // C·∫≠p nh·∫≠t danh s√°ch followers v√† following
      await followUser.updateOne({ $push: { followers: _id } });
      await followingUser.updateOne({ $push: { following: userId } });

      // T·∫°o th√¥ng b√°o cho ng∆∞·ªùi ƒë∆∞·ª£c follow
      const notification = new Notification({
        userId: userId, // Ng∆∞·ªùi nh·∫≠n th√¥ng b√°o
        senderId: _id, // Ng∆∞·ªùi g·ª≠i th√¥ng b√°o (ng∆∞·ªùi follow)
        message: `${followingUser.username} ƒë√£ follow b·∫°n`, // N·ªôi dung th√¥ng b√°o
        type: "follow",
      });
      await notification.save();

      return res.status(200).json({
        message: "Follow successful and notification created",
        data: notification,
      });
    } else {
      // N·∫øu ng∆∞·ªùi d√πng ƒë√£ theo d√µi
      return res.status(403).json({ message: "B·∫°n ƒë√£ theo d√µi ng∆∞·ªùi n√†y r·ªìi" });
    }
  } catch (error) {
    return res.status(500).json({ message: error.message });
  }
};
export const updateXP = async (req, res) => {
  try {
    const { userId, xpEarned } = req.body; // L·∫•y ID ng∆∞·ªùi d√πng v√† XP nh·∫≠n ƒë∆∞·ª£c

    if (!userId || typeof xpEarned !== "number") {
      return res
        .status(400)
        .json({ message: "Thi·∫øu userId ho·∫∑c xpEarned kh√¥ng h·ª£p l·ªá" });
    }

    const user = await UserModel.findById(userId);
    if (!user) {
      return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng" });
    }

    user.xp += xpEarned; // C·ªông XP m·ªõi v√†o XP hi·ªán t·∫°i

    // X√°c ƒë·ªãnh XP t·ªëi ƒëa c·∫ßn ƒë·ªÉ l√™n level ti·∫øp theo
    let maxXP = user.level * 500;
    while (user.xp >= maxXP) {
      user.xp -= maxXP; // Tr·ª´ XP ƒë√£ v∆∞·ª£t m·ª©c
      user.level += 1; // TƒÉng level
      maxXP = user.level * 500; // C·∫≠p nh·∫≠t XP t·ªëi ƒëa m·ªõi
    }

    await user.save();

    return res.json({
      message: "XP ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t!",
      xp: user.xp,
      level: user.level,
    });
  } catch (error) {
    console.error("L·ªói khi c·∫≠p nh·∫≠t XP:", error);
    res.status(500).json({ message: "L·ªói server" });
  }
};

export const updateUserLevel = async (req, res) => {
  try {
    const userId = req.params.id;
    const { newXp } = req.body;

    const user = await UserModel.findById(userId);
    if (!user) {
      return res.status(404).json({ message: "Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i" });
    }

    // C·∫≠p nh·∫≠t XP v√† Level
    user.xp = newXp;
    const newLevel = Math.floor(newXp / 500) + 1;
    user.level = newLevel;

    // üåü G√°n badge theo Level
    const levelBadgeMap = [
      { level: 1, badges: 578 }, // Th√†nh vi√™n m·ªõi
      { level: 3, badges: 624 }, // Th√†nh vi√™n ƒë·ªìng
      { level: 5, badges: 684 }, // Th√†nh vi√™n b·∫°c
      { level: 7, badges: 612 }, // Th√†nh vi√™n v√†ng
      { level: 10, badges: 999 }, // Th√†nh vi√™n kim c∆∞∆°ng
    ];

    // T√¨m badge ph√π h·ª£p nh·∫•t
    const matchingBadge = levelBadgeMap
      .filter((entry) => newLevel >= entry.level)
      .pop(); // L·∫•y badge cao nh·∫•t theo level ƒë·∫°t ƒë∆∞·ª£c

    if (matchingBadge) {
      user.badges = [matchingBadge.badge]; // C·∫≠p nh·∫≠t badge
    }

    await user.save(); // L∆∞u v√†o DB

    return res.json({
      message: "C·∫≠p nh·∫≠t level & danh hi·ªáu th√†nh c√¥ng!",
      level: user.level,
      xp: user.xp,
      badges: user.badges,
    });
  } catch (error) {
    console.error("L·ªói c·∫≠p nh·∫≠t level:", error);
    return res.status(500).json({ message: "L·ªói server" });
  }
};

// export const updateXP = async (req, res) => {
//   try {
//     const { userId } = req.params;
//     const xpGained = Math.floor(Math.random() * 500) + 100; // XP ng·∫´u nhi√™n t·ª´ 100 - 500

//     let user = await UserModel.findById(userId);
//     if (!user) {
//       return res.status(404).json({ message: "User not found" });
//     }

//     user.xp += xpGained;

//     // Ki·ªÉm tra n·∫øu ƒë·ªß XP ƒë·ªÉ l√™n c·∫•p
//     const nextLevelXP = user.level * 500;
//     if (user.xp >= nextLevelXP) {
//       user.level += 1;
//       user.xp = 0; // Reset XP sau khi l√™n c·∫•p
//     }

//     await user.save();

//     res.json({
//       status: "Success",
//       xp: user.xp,
//       level: user.level,
//       xpGained,
//     });
//   } catch (error) {
//     console.log(error);
//     res.status(500).json({ message: "Error updating XP" });
//   }
// };
const calculateXPMax = (level) => {
  return 500 * level; // Level 1: 500, Level 2: 1000, Level 3: 1500, ...
};

export const getUserXP = async (req, res) => {
  try {
    const { userId } = req.params;
    const user = await UserModel.findById(userId);

    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    res.json({
      xp: user.xp,
      level: user.level,
      xpMax: calculateXPMax(user.level),
    });
  } catch (error) {
    console.log(error);
    res.status(500).json({ message: "Error fetching XP data" });
  }
};

export const getContractsForFinder = async (req, res) => {
  try {
    const { userId } = req.params; // L·∫•y userId c·ªßa finder t·ª´ request

    const contracts = await ContractModel.find({ "finder.userId": userId })
      .populate("finder.userId", "username email")
      .populate("loser.userId", "username email")
      .populate("postId", "desc image");

    if (!contracts || contracts.length === 0) {
      return res.status(404).json({ message: "Kh√¥ng c√≥ h·ª£p ƒë·ªìng n√†o." });
    }

    res.json({ status: "success", data: contracts });
  } catch (error) {
    console.error("L·ªói l·∫•y h·ª£p ƒë·ªìng cho Finder:", error);
    res.status(500).json({ message: "L·ªói m√°y ch·ªß." });
  }
};
export const getNotifications = async (req, res) => {
  try {
    const { userId } = req.params; // userId l√† ID c·ªßa ng∆∞·ªùi d√πng mu·ªën l·∫•y th√¥ng b√°o

    // L·∫•y t·∫•t c·∫£ th√¥ng b√°o cho ng∆∞·ªùi d√πng
    const notifications = await Notification.find({ userId })
      .sort({ createdAt: -1 }) // S·∫Øp x·∫øp th√¥ng b√°o m·ªõi nh·∫•t l√™n ƒë·∫ßu
      .limit(10); // Gi·ªõi h·∫°n 10 th√¥ng b√°o g·∫ßn nh·∫•t

    return res.status(200).json({
      message: "Notifications fetched successfully",
      data: notifications,
    });
  } catch (error) {
    console.error(error);
    return res.status(500).json({ message: "Error in fetching notifications" });
  }
};
// Controller b·ªè theo d√µi user
export const unfollowUser = async (req, res) => {
  const id = req.params.id;
  const { _id } = req.body;

  if (_id === id) {
    return res.status(403).json({ message: "B·∫°n ko th·ªÉ unfollow ch√≠nh m√¨nh" });
  }

  try {
    const followUser = await UserModel.findById(id);
    const followingUser = await UserModel.findById(_id);

    if (followUser.followers.includes(_id)) {
      await followUser.updateOne({ $pull: { followers: _id } });
      await followingUser.updateOne({ $pull: { following: id } });

      return res.status(200).json({ message: "B·ªè theo d√µi th√†nh c√¥ng!" });
    } else {
      return res.status(403).json({ message: "B·∫°n ch∆∞a theo d√µi ng∆∞·ªùi n√†y!" });
    }
  } catch (error) {
    console.error(error);
    return res.status(500).json({ message: "Failed to unfollow the user!" });
  }
};
// Ki·ªÉm tra tr·∫°ng th√°i follow gi·ªØa hai ng∆∞·ªùi d√πng
export const fetchFollowingStatus = async (req, res) => {
  const { currentUserId } = req.query; // L·∫•y currentUserId t·ª´ query
  const { targetUserId } = req.params; // L·∫•y targetUserId t·ª´ params

  try {
    // Ki·ªÉm tra n·∫øu c·∫£ hai userId ƒë∆∞·ª£c truy·ªÅn
    if (!currentUserId || !targetUserId) {
      return res.status(400).send({ message: "Missing parameters" });
    }

    // T√¨m user ƒë∆∞·ª£c theo d√µi
    const targetUser = await UserModel.findById(targetUserId);

    if (!targetUser) {
      return res.status(404).json({ message: "Target user not found." });
    }

    // Ki·ªÉm tra currentUserId c√≥ trong danh s√°ch followers kh√¥ng
    const isFollowing = targetUser.followers.includes(currentUserId);

    return res.status(200).json({ isFollowing }); // Tr·∫£ v·ªÅ tr·∫°ng th√°i follow
  } catch (error) {
    console.error("Error fetching follow status:", error);
    return res
      .status(500)
      .json({ message: "L·ªói user ƒë√£ x√≥a t√†i kho·∫£n ho·∫∑c kh√¥ng k·∫øt n·ªëi ƒë∆∞·ª£c." });
  }
};
export const searchUser = async (req, res) => {
  try {
    const query = req.query.q || "";
    const users = await UserModel.find({
      $or: [
        { username: { $regex: query, $options: "i" } },
        { firstname: { $regex: query, $options: "i" } },
        { lastname: { $regex: query, $options: "i" } },
        { email: { $regex: query, $options: "i" } },
      ],
    });
    res.json(users);
  } catch (error) {
    res.status(500).json({ error: "L·ªói khi t√¨m ki·∫øm ng∆∞·ªùi d√πng" });
  }
};
export const searchPost = async (req, res) => {
  try {
    const query = req.query.q || "";
    const posts = await PostModel.find({
      desc: { $regex: query, $options: "i" },
    }).populate("userId", "username profilePic");
    res.json(posts);
  } catch (error) {
    res.status(500).json({ error: "L·ªói khi t√¨m ki·∫øm b√†i ƒëƒÉng" });
  }
};
export const rewardPoint = async (req, res) => {
  try {
    const { userId } = req.params;
    const xp = Number(req.body.xp);

    // Ki·ªÉm tra xem xp c√≥ h·ª£p l·ªá kh√¥ng
    if (!Number.isFinite(xp) || xp <= 0) {
      return res.status(400).json({ message: "XP kh√¥ng h·ª£p l·ªá" });
    }

    // T√¨m ng∆∞·ªùi d√πng theo ID
    const user = await UserModel.findById(userId);
    if (!user) {
      return res.status(404).json({ message: "Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i" });
    }

    // ƒê·∫£m b·∫£o user.xp l√† s·ªë h·ª£p l·ªá tr∆∞·ªõc khi c·ªông XP
    user.xp = Number.isFinite(user.xp) ? user.xp + xp : xp;

    // T√≠nh to√°n level m·ªõi d·ª±a tr√™n XP (m·ªói 500 XP l√™n 1 level)
    user.level = Math.floor(user.xp / 500) + 1;

    // L∆∞u th√¥ng tin c·∫≠p nh·∫≠t
    await user.save();

    return res.json({
      message: `B·∫°n ƒë√£ nh·∫≠n ƒë∆∞·ª£c ${xp} XP!`,
      newXp: user.xp,
      newLevel: user.level,
    });
  } catch (error) {
    console.error("L·ªói c·∫≠p nh·∫≠t XP:", error);
    res.status(500).json({ message: "L·ªói server, kh√¥ng th·ªÉ c·∫≠p nh·∫≠t XP." });
  }
};

export const updateUserXP = async (userId, xpToAdd) => {
  try {
    const user = await UserModel.findById(userId);
    if (!user) {
      console.error("Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng ƒë·ªÉ c·∫≠p nh·∫≠t XP.");
      return;
    }

    user.xp = (user.xp || 0) + xpToAdd; // C·ªông th√™m XP v√†o XP hi·ªán t·∫°i
    await user.save();
  } catch (error) {
    console.error("L·ªói khi c·∫≠p nh·∫≠t XP:", error);
  }
};

export const contract = async (req, res) => {
  // try {
  //   const { finderId, loserId, images } = req.body;
  //   // Ki·ªÉm tra xem finderId v√† loserId c√≥ h·ª£p l·ªá kh√¥ng
  //   const finder = await UserModel.findById(finderId);
  //   const loser = await UserModel.findById(loserId);
  //   if (!finder || !loser) {
  //     return res.status(404).json({ message: "Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i." });
  //   }
  //   // T·∫°o h·ª£p ƒë·ªìng m·ªõi
  //   const newContract = new {
  //     finder: finderId,
  //     loser: loserId,
  //     image: images || [],
  //     status: "pending",
  //   }();
  //   // L∆∞u h·ª£p ƒë·ªìng v√†o database
  //   await newContract.save();
  //   res.status(201).json({
  //     status: "Success",
  //     message: "H·ª£p ƒë·ªìng ƒë√£ ƒë∆∞·ª£c t·∫°o.",
  //     data: newContract,
  //   });
  // } catch (error) {
  //   console.error("L·ªói khi t·∫°o h·ª£p ƒë·ªìng:", error);
  //   res.status(500).json({ message: "L·ªói khi t·∫°o h·ª£p ƒë·ªìng." });
  // }
};
export const addContract = async (req, res) => {
  try {
    const { finderId, loserId, postId, images } = req.body;

    if (!finderId || !loserId || !postId) {
      return res.status(400).json({ message: "Thi·∫øu th√¥ng tin h·ª£p ƒë·ªìng!" });
    }

    if (finderId === loserId) {
      return res
        .status(400)
        .json({ message: "Kh√¥ng th·ªÉ t·∫°o h·ª£p ƒë·ªìng v·ªõi ch√≠nh m√¨nh!" });
    }

    // Ki·ªÉm tra ng∆∞·ªùi d√πng v√† b√†i ƒëƒÉng t·ªìn t·∫°i kh√¥ng
    const finder = await UserModel.findById(finderId);
    const loser = await UserModel.findById(loserId);
    const post = await PostModel.findById(postId);

    if (!finder || !loser || !post) {
      return res
        .status(404)
        .json({ message: "Ng∆∞·ªùi d√πng ho·∫∑c b√†i ƒëƒÉng kh√¥ng t·ªìn t·∫°i!" });
    }

    // Ki·ªÉm tra xem h·ª£p ƒë·ªìng ƒë√£ t·ªìn t·∫°i ch∆∞a
    const existingContract = await ContractModel.findOne({ postId });

    if (existingContract) {
      return res
        .status(400)
        .json({ message: "H·ª£p ƒë·ªìng cho b√†i vi·∫øt n√†y ƒë√£ t·ªìn t·∫°i." });
    }

    // T·∫°o h·ª£p ƒë·ªìng m·ªõi
    const newContract = new ContractModel({
      finder: { userId: finderId, images },
      loser: { userId: loserId },
      postId,
    });

    await newContract.save();

    res
      .status(201)
      .json({ message: "H·ª£p ƒë·ªìng ƒë√£ ƒë∆∞·ª£c t·∫°o!", contract: newContract });
  } catch (error) {
    console.error("L·ªói khi t·∫°o h·ª£p ƒë·ªìng:", error);
    res.status(500).json({ message: "L·ªói m√°y ch·ªß, vui l√≤ng th·ª≠ l·∫°i!" });
  }
};

// export const updateUserLevel = async (req, res) => {
//   try {
//     const { userId } = req.params;
//     const user = await UserModel.findById(userId);
//     if (!user) {
//       return res.status(404).json({ message: "User not found" });
//     }

//     // T√≠nh to√°n level d·ª±a tr√™n nƒÉm ƒëƒÉng k√Ω
//     const currentYear = new Date().getFullYear();
//     const registrationYear = user.createdAt.getFullYear();
//     const yearsRegistered = currentYear - registrationYear;

//     // G√°n level m·ªõi
//     const newLevel = yearsRegistered > 5 ? 5 : yearsRegistered; // Gi·ªõi h·∫°n max l√† 5

//     // C·∫≠p nh·∫≠t danh hi·ªáu (badges)
//     let newBadges = [...user.badges];
//     if (!newBadges.includes(newLevel)) {
//       newBadges.push(newLevel);
//     }

//     if (user.level !== newLevel) {
//       user.level = newLevel;
//       user.badges = newBadges;
//       await user.save();
//     }

//     return res.status(200).json({
//       level: user.level,
//       levelText: getLevelText(user.level),
//       badges: user.badges.map(getLevelText),
//     });
//   } catch (error) {
//     console.error("L·ªói c·∫≠p nh·∫≠t c·∫•p ƒë·ªô:", error);
//     return res.status(500).json({ message: "L·ªói c·∫≠p nh·∫≠t c·∫•p ƒë·ªô" });
//   }
// };

export const acceptContract = async (req, res) => {
  try {
    const { id } = req.params;
    const { status } = req.body;

    // Ki·ªÉm tra tr·∫°ng th√°i h·ª£p l·ªá
    if (!["pending", "confirmed", "rejected"].includes(status)) {
      return res.status(400).json({ message: "Tr·∫°ng th√°i kh√¥ng h·ª£p l·ªá." });
    }

    // C·∫≠p nh·∫≠t tr·∫°ng th√°i h·ª£p ƒë·ªìng
    const contract = await ContractModel.findByIdAndUpdate(
      id,
      { status },
      { new: true }
    );

    if (!contract) {
      return res.status(404).json({ message: "H·ª£p ƒë·ªìng kh√¥ng t·ªìn t·∫°i." });
    }

    return res.status(200).json({
      message: "C·∫≠p nh·∫≠t tr·∫°ng th√°i th√†nh c√¥ng.",
      contract,
    });
  } catch (error) {
    console.error("L·ªói c·∫≠p nh·∫≠t tr·∫°ng th√°i:", error);
    res.status(500).json({ message: "L·ªói server." });
  }
};
export const fetchContract = async (req, res) => {
  try {
    const contracts = await ContractModel.find()
      .populate("finder.userId", "username") // L·∫•y th√¥ng tin ng∆∞·ªùi t√¨m
      .populate("loser.userId", "username") // L·∫•y th√¥ng tin ng∆∞·ªùi b·ªã m·∫•t
      .populate("postId", "desc"); // L·∫•y th√¥ng tin b√†i ƒëƒÉng

    res.status(200).json(contracts);
  } catch (error) {
    console.error("L·ªói l·∫•y danh s√°ch h·ª£p ƒë·ªìng:", error);
    res.status(500).json({ message: "L·ªói server." });
  }
};
export const changePassword = async (req, res) => {
  const { oldPassword, newPassword } = req.body;
  const userId = req.user._id;

  // Ki·ªÉm tra xem m·∫≠t kh·∫©u c≈© v√† m·ªõi ƒë√£ ƒë∆∞·ª£c nh·∫≠p ƒë·∫ßy ƒë·ªß ch∆∞a
  if (!oldPassword || !newPassword) {
    return res.status(400).json({ message: "Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß th√¥ng tin" });
  }

  // Ki·ªÉm tra ƒë·ªô d√†i c·ªßa m·∫≠t kh·∫©u m·ªõi
  if (newPassword.length < 6) {
    return res
      .status(400)
      .json({ message: "M·∫≠t kh·∫©u m·ªõi ph·∫£i c√≥ √≠t nh·∫•t 6 k√Ω t·ª±" });
  }

  try {
    // T√¨m ng∆∞·ªùi d√πng trong c∆° s·ªü d·ªØ li·ªáu
    const user = await UserModel.findById(userId);
    if (!user) {
      return res.status(404).json({ message: "Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i" });
    }

    // Ki·ªÉm tra m·∫≠t kh·∫©u c≈©
    const isMatch = await bcrypt.compare(oldPassword, user.password);
    if (!isMatch) {
      return res.status(400).json({ message: "M·∫≠t kh·∫©u c≈© kh√¥ng ch√≠nh x√°c" });
    }

    // BƒÉm m·∫≠t kh·∫©u m·ªõi
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(newPassword, salt);

    // C·∫≠p nh·∫≠t m·∫≠t kh·∫©u m·ªõi
    user.password = hashedPassword;
    await user.save();

    // Tr·∫£ v·ªÅ th√¥ng b√°o th√†nh c√¥ng
    res.status(200).json({ message: "M·∫≠t kh·∫©u ƒë√£ ƒë∆∞·ª£c thay ƒë·ªïi th√†nh c√¥ng" });
  } catch (error) {
    console.error("Error changing password:", error);
    res.status(500).json({ error: "C√≥ l·ªói x·∫£y ra khi thay ƒë·ªïi m·∫≠t kh·∫©u" });
  }
};
